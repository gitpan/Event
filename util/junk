sub waitForEvents {
    # OPTIMIZE (2)

    # prepare can probably be reduced to checking:
    #   $queueCount, next timer, and @Idle

#    warn "events:\n";
#    for (&Event::timer::List) { warn join(' ', %$_)."\n"; }

    my $wait = $queueCount + wantIdle() ? 0 : 3600;
    $wait = min $wait, (map { $_->() } @Prepare);

    warn "Event::waitForEvents: wait=$wait\n"
	if $Event::DebugLevel >= 3;
    Event::io::waitForEvent($wait);

    for my $x (@Check) { $x->() }

    if ($wait) {
	# We only need to re-check if WaitForEvent actually
	# waited for a "non-zero" amount of time.
	for my $x (@AsyncCheck) { $x->() }
    }
}

sub DEBemptyQueue {
    warn "queue:\n";
    for (&Event::Loop::listQ) { warn join (' ', %$_)."\n"; }
    emptyQueue();
}

sub doOneEvent {
    # OPTIMIZE (2)

    for my $x (@AsyncCheck) { $x->() }

    return 1 if emptyQueue();

    waitForEvents();

    return 1 if emptyQueue();

    runIdle();
}



void
RealSigName(sv)
    SV * sv
PROTOTYPE: $
PPCODE:
    char *s = SvPV(sv,na);
    if(s && *s == '_') {
	if(strNE(s,"__DIE__") && strNE(s,"__WARN__") && strNE(s,"__PARSE__"))
	    ST(0) = &sv_undef;
    }
    else {
	int sig = whichsig(s);
	if(sig) {
	    ST(0) = sv_newmortal();
	    sv_setpv(ST(0),sig_name[sig]);
	}
	else
	    ST(0) = &sv_undef;
    }
    XSRETURN(1);
